# 微服务内存占用高
<img width="1719" height="756" alt="image" src="https://github.com/user-attachments/assets/b0445467-4695-446d-9389-d49457dd99ef" />
<img width="858" height="435" alt="image" src="https://github.com/user-attachments/assets/514ff914-18c6-481b-94b1-7d7169afbcd3" />
<img width="1037" height="220" alt="image" src="https://github.com/user-attachments/assets/124753bc-047b-47a3-9140-5a0f6ff2dcbf" />
GC日志：
<img width="1639" height="522" alt="image" src="https://github.com/user-attachments/assets/51d324fe-12c7-4210-9b16-e0454c72d224" />

排查方法：

1. jmap -histo: 生成Java堆内存中对象统计直方图

jmap -histo <pid>                          # 显示存活对象的直方图

jmap -histo:live <pid>                     # 只显示在Full GC后仍然存活的对象（更常用）

2. jcmd 1 GC.heap_info：JVM堆内存的整体布局和使用情况

3. jstat -gcutil 1 1000：实时监控JVM垃圾收集和堆内存使用情况

分析：

Young区：每次回收后剩余约30MB (从1.17GB回收掉1.14GB)

堆内存：总使用量维持在2.3GB左右，老年代占用约1.08GB

可能有大对象/缓存常驻老年代

所有GC原因都是Allocation Failure，表明Eden区设置可能偏小

原因：

1. 年轻代过大导致回收效率低
  
2. Survivor区利用率低

解决方案：

jvm增加参数：JAVA_OPTS="$JAVA_OPTS -XX:MaxRAMPercentage=75.0"  JAVA_OPTS="$JAVA_OPTS -XX:+UseContainerSupport" 

将最大堆内存设置为容器总可用内存的75%。这个百分比是基于容器内存限制来计算的，而不是物理机内存。







